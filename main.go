package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strconv"
	"strings"
)

const (
	GeneratedSignature = "Generated by Baschmet, Lev Aminov <l.aminov@tinkoff.ru>"
)

func GetChartVariables(chartDir string, options *Options) (*Variables, error) {
	chartFile := path.Join(chartDir, "Chart.yaml")
	chart, err := ChartFromFile(chartFile)
	if err != nil {
		return nil, err
	}
	metaFile := path.Join(chartDir, "..", "meta.yaml")
	meta, err := MetaFromFile(metaFile)
	if err != nil {
		return nil, err
	}
	return &Variables{
		Options:     options,
		Chart:       chart,
		Meta:        meta,
		GeneratedBy: GeneratedSignature,
	}, nil
}

func FilePathWalkDir(root string) ([]string, error) {
	var files []string
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if !info.IsDir() {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

func realMain(dryRun bool) int {
	options, err := OptionsFromFile("options.yaml")
	if err != nil {
		fmt.Println(err)
		return 1
	}
	args := os.Args[1:]
	if len(args) == 0 {
		fmt.Println("Nothing to do.")
		return 0
	}
	for _, chartDir := range args {
		if _, err := os.Stat(chartDir); os.IsNotExist(err) {
			continue
		}
		rootDir := path.Join(chartDir, "../..")
		vars, err := GetChartVariables(chartDir, options)
		if err != nil {
			fmt.Println(err)
			return 1
		}
		templFiles, err := FilePathWalkDir("templates/")
		if err != nil {
			fmt.Println(err)
			return 1
		}
		fmt.Println(vars.Chart.String())
		for _, templFile := range templFiles {
			relPath := strings.TrimPrefix(templFile, "templates/")
			resultPath := path.Join(rootDir, relPath)
			fmt.Println(resultPath)
			templ, err := GetTemplateText(templFile)
			if err != nil {
				fmt.Println(err)
				return 2
			}
			text, err := GenerateTemplate(templ, "gitlab", vars)
			if err != nil {
				fmt.Println(templFile, err)
				return 2
			}
			if dryRun {
				fmt.Println(resultPath)
				fmt.Println(text)
				continue
			}
			err = ioutil.WriteFile(resultPath, []byte(text), 0644)
			if err != nil {
				fmt.Println(err)
				return 2
			}
		}
	}
	return 0
}

func main() {
	var dryRun bool
	dryRunRaw := os.Getenv("DRY_RUN")
	if len(dryRunRaw) == 0 {
		dryRun = true
	} else {
		b, err := strconv.ParseBool(dryRunRaw)
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		dryRun = b
	}
	os.Exit(realMain(dryRun))
}
